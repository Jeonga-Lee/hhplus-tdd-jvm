# 동시성 제어 방식에 대한 분석 및 보고서

## 1. 개요

본 프로젝트에서는 4가지 기본 기능인 **포인트 조회**, **포인트 충전**, **포인트 사용**, **포인트 사용 내역 조회**를 구현하였으며,
**동시성 제어**를 통해 여러 요청이 동시에 들어올 경우에도 순서대로 처리되도록 하였습니다.

## 2. 동시성 제어

### 2.1. 동시성 제어 요구사항

- **같은 유저에 대한 요청은 순서대로 처리**되어야 합니다.
- **서로 다른 유저에 대한 요청은 동시에 실행**될 수 있습니다.

### 2.2. 동시성 제어 방식

동시성 제어를 구현하기 위해 두 가지 주요 개념을 사용하였습니다.

1. **ReentrantLock**: 락을 명시적으로 관리하고, `lock()`과 `unlock()`을 사용하여 동기화합니다.
2. **ConcurrentHashMap**: 락 객체를 안전하게 관리하며, `computeIfAbsent` 메서드를 사용하여 락을 효율적으로 생성하고 저장할 수 있습니다.

해당 방식을 구현한 코드는 /point/service/LockPointService 에 있습니다.

### 2.3. 사용자별 락 관리

동시에 여러 요청이 들어올 때 **같은 유저에 대한 요청**은 순서대로 처리하고, **서로 다른 유저에 대한 요청**은 동시에 처리할 수 있도록 하기 위해,
**사용자별 락**을 관리하는 방식으로 동시성을 제어합니다.

#### 2.3.1. `ConcurrentHashMap<Long, ReentrantLock>` 사용

- 사용자 ID를 **키**로 하고, 각 사용자마다 고유의 **ReentrantLock**을 생성하여 맵에 저장합니다.
- `computeIfAbsent` 메서드를 사용하여 사용자가 처음 등장할 경우 새 락을 생성하고 반환합니다.
- 이를 통해, 각 사용자에 대해 락을 독립적으로 관리하여 동시성 문제를 해결합니다.

#### 2.3.2. `getLockForUser(long userId)` 메서드

- 이 메서드는 `ConcurrentHashMap`에서 해당 사용자 ID에 맞는 락을 가져옵니다.
- 락이 존재하지 않으면 새로운 락을 생성하여 반환합니다.

### 2.4. `charge`와 `use` 메서드에서 락 사용

- **charge**와 **use** 메서드에서 **사용자별 락**을 사용하여 동시성을 처리합니다.
- 각 사용자에 대해 별도의 락을 사용하므로, 동일 사용자에 대해 동시에 요청이 들어와도 순차적으로 처리됩니다.
- 다른 사용자에 대해서는 병렬로 처리할 수 있습니다.

### 2.5. 사용자별 락 관리

- **사용자별 락**: 각 사용자에 대해 별도의 락을 관리하므로, 동일 사용자에 대해서만 동시성 제어를 하며, 다른 사용자는 서로 독립적으로 작업을 수행할 수 있습니다.
- 이를 통해 **동일 사용자의 요청**만 동기화하고, **다른 사용자의 요청**은 병렬로 처리할 수 있습니다.

### 2.6. 성능 최적화

`ConcurrentHashMap`을 사용하여 사용자별로 **ReentrantLock**을 관리함으로써, 동시성 제어를 효과적으로 수행하면서 성능을 최적화할 수 있습니다.
이 방식은 **동일 사용자의 요청**에 대해서만 동시성을 제어하고, **다른 사용자의 요청**은 병렬로 처리할 수 있도록 하여 **성능을 최적화**하면서도 동시성 문제를
해결합니다.